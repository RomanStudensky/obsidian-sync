**Шардирование, партиционироавние, регионирование или сегментирование**: это всё одно и тоже.

**Основная цель** секционирования - *масштабирование*.

Секции можно разместить на разных узлах в кластере (на разных кластерах?) не предусматривающем разделения ресурсов.

## Секционирование и [[Репликация]]

Обычно копии каждой из секций хранятся на нескольких узлах для отказоустойчивости.
Репликация и секционирование "Ведущий - ведомый"

![[Pasted image 20251024162757.png]]

## Секционирование типа "ключ - значение"

Цель секционирования - равномерно распределить по узлам данные и нагрузку по запросам. Если доли всех узлов примерно равны, то в теории можно говорить, что 10 узлов обработают в 10 раз больше данных чем 1, т.е. будет 10 кратный прирост. Иначе секционирование будет **ассиметричным (skewed)**. 
Секция с наибольшей нагрузкой - горячая **точка (hot spot)**. Простой способ её избежать - рандомно назначить узлы для записей. Минус, что при чтении неизвестно в каком узле лежат данные.

## Секционирование по диапазонам значений ключа

Назначение каждой из секций непрерывный диапазон значений ключа (от минимального до максимального значения). Если известны границы между диапазонами, то можно легко определить, в какой секции содержится нужный ключ. Границы могут выбираться админом или автоматически СУБД.
В качестве ключа можно использовать временную метку, это удобно, например, для записи и поиска данных с датчиков. Однако есть минус - загрузка одной секции т.к. сегодняшние данные пойдут в нее, а остальные секции будут простаивать. Можно припудрить, если секционировать по названию датчика, а после времени.

## Секционирование по хешу ключа

Для избежания асимметрии используется хеш ключа. Значение кладется в соответствующую секцию, в диапазон которой значение хеша попадает. Работает наподобие *HashMap* в *Java*.


## Асимметричные нагрузки и разгрузка горячих точек

Хеш секционирование разгрузит горячие точки, но не совсем. Когда все запросы выполняются для одного ключа, все они приходятся на одну секцию.
Это необычная ситуация, однако имеет место быть. Например действия на страницах знаменитостей могут вызывать бурю активности и огромное количество записей в одну секцию.
На данный момент нет коробочного решения этой проблемы. Однако можно "*подсолить*" добавить в начало горячего ключа случайное число. Простое двузначное десятичное, что позволит размазать записи для ключа равномерно по 10 различным ключам.

## Вторичные индексы

Если ищем запись по первичному ключу, то - ок. Если же нужно искать по другим признакам, вхождениям - пользуемся вторичным индексом.
Основная их проблема в том, что нельзя поставить их в чёткое соответствие секциям.

### Секционирование вторичных индексов по документам

Секционирование документов (запись в БД или документ в NoSQL) по разным секциям, при том индексы содержатся во всех секциях.

![[Pasted image 20251026144854.png]]

---
### Секционирование вторичных индексов по термам

Секционирование по термам - разнесение диапазонов индексов по разным секциям, при том идентификаторы документов могут повторяться в разных секциях.

![[Pasted image 20251026145223.png]]

---
## Перебалансировка секций

С течением времени положение дел в БД меняется:
- растет *RPS*;
- объем данных растет;
- сервера выходят из строя и другие подхватывают их обязанности.

Перемещение нагрузки с одного узла кластера на другой - *перебалансировка*.

Требования перебалансировки:
- равномерное распределение нагрзки по узлам кластера;
- БД не должна простаивать;
- между узлами должно перемещаться ровно столько данных, сколько нужно для ускорения перебалансировки и минимизации нагрузки по вводу/выводу на сеть и жесткие диски.

### Способы перебалансировки

#### Хешировние по модулю N

Так делать не надо. Делать количество секций по количеству рабочих узлов не нужно т.к. оно может меняться. 

#### Фиксированное количество секций

Лучше сделать количество секций фиксированным и намного большим количества узлов. Однако выбирать слишком большое кол-во тоже не разумно т.к. это приносит накладные расходы. В каждый узел будет добавлено несколько секций.
При добавлении нового узла, ему перейдут несколько секций из других узлов. При удалении будет обратный процесс.
Так же это можно изменять, например можно отдать более производительным узлам больше секций. 

![[Pasted image 20251026154920.png]]


#### Динамическое секционирование

Для БД фиксированное кол-во не удобно т.к. может оказаться что большинство данных может оказаться в одной секции, а остальные буду мало нагружены или пусты. Чтобы этого избежать применяют динамическое секционирование. Когда размер секции перерастает определенное значение, она разделяется. Наоборот при уменьшении данных происходит склеивание.
Когда данных в БД еще нет, создается одна секция на одном узле до момента достаточного наполнения данных. Чтобы минимизировать влияние этого фактора некоторые СУБД задают такое кол-во вручную. 

#### Секционирование пропорционально количеству узлов

Можно задать количество, которое будет пропорционально кол-ву секций.

## Маршрутизация запросов

После секционирования нужно решить проблему поиска данных. 
Маршрутизация - частный случай *обнаружения сервисов (service discovery)*. 

Есть несколько способов решения этой задачи.

1. Разрешить клиентам обращаться к любому узлу. Если секция есть на узле, вернется ответ иначе запрос уйдет на нужный узел;
2. Ходить через маршрутизатор;
3. Клиент сам будет знать где лежат правильные данные.

![[Pasted image 20251026163509.png]]

Проблема в том, что маршрутизатор должен знать где находится правильный узел и куда он перемещается при перебалансировке.
Обычно для этого используется стороннее хранилище, которое знает куда делать запрос
Коробочное решение - сервис координации ZooKeeper. При изменеениях в узлах сервис оповещает маршрутизатор об этом.

![[Pasted image 20251026164215.png]]


#### Параллельное выполнение запросов

В основном все простые запросы поддерживают большинство распределенных хранилищ NoSQL. Реляционные БД с массово параллельной архитектурой, часто используемые для аналитики, поддерживают гораздо более сложные типы запросов. Типичный запрос склада данных содержит операции фильтрации, соединения, группировки и агрегирования. Оптимизатор таких БД разбивает сложный запрос на несколько стадий выполнения и секций, и многие из них можно выполнять параллельно в различных узлах кластера БД.

