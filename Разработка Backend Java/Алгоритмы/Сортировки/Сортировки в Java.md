**Сортировка массивов:**
- Arrays.sort(int[], long[] ...) - для примитивов
	Dual Pivotal Quicksort (неустойчиво к порядку элементов при одинаковых ключах)
	Сложность: в среднем O(n log n), в худшем O(n^2) 
	Память O log(n) за стек рекурсии

- Arrays.sort для объектов (Object[], Comparator/Comparable)
	TimSort (устойчивый) — гибрид merge + вставки, ищет «естественные» возрастания (runs), есть «галопирующее» слияние.
    Сложность: O(n log n) в худшем, близко к O(n) на почти отсортированных данных.
	Память: O(n) в худшем (доп. буфер).

- Collections.sort(list) / List.sort
	Делегирует к Arrays.sort(Object[]) → тот же стабильный TimSort.
	Для произвольных List обычно копирует в массив, сортирует, копирует назад.

- Arrays.parallelSort (Java 8+)
	Алгоритм: параллельное «разделяй-и-властвуй» на ForkJoin: массив дробится на блоки, каждый блок сортируется теми же алгоритмами (примитивы — dual-pivot quicksort, объекты — TimSort), затем параллельно сливается (merge).
	
	Плюс на больших n и многоядерных CPU.
	Стабильность: для объектов сохраняется (как у TimSort), для примитивов — нет.

- Мелочи и поведение
	Устойчивость: объекты — да, примитивы — нет.
    Пороговые оптимизации: для маленьких сегментов используется insertion sort.
    Null-ы: поддерживаются при Comparator’е, по умолчанию — NPE (если не Comparable).
