**Процесс** — это независимая программа, запущенная в операционной системе. Каждый процесс имеет своё адресное пространство, системные ресурсы и может содержать один или несколько потоков.

**Поток** — это наименьшая единица исполнения в операционной системе, которая выполняется в контексте процесса. Потоки одного процесса разделяют ресурсы, такие как память и файлы.



**[[Happens-before]]** — это фундаментальное понятие в Java Memory Model (JMM), которое определяет правила порядка выполнения операций в многопоточном окружении. Оно помогает разработчикам понимать, какие изменения в памяти, сделанные одним потоком, будут видны другим потокам, и в каком порядке операции выполняются относительно друг друга.

**Почему это важно?**

В многопоточном приложении без правильной синхронизации потоки могут видеть несогласованные или устаревшие данные из-за особенностей работы процессоров и кэш-памяти. Happens-before отношения устанавливают гарантии видимости и порядка исполнения операций, позволяя безопасно обмениваться данными между потоками.

Если в потоке _A_ операция _a_ происходит перед _b_, то a happens-before _b_.

Volatile – позволяет не кэшировать данные после обработки в одном потоке, чтобы изменения были видны другому потоку.

  

Состояния потоков в Java

В Java поток (Thread) может находиться в одном из шести состояний, определенных в перечислении java.lang.Thread.State. Эти состояния отражают жизненный цикл потока и помогают понять, что происходит с потоком в данный момент. Вот список возможных состояний потоков в Java:

NEW (Новый)

Когда создан как объект

RUNNABLE (Готовый к выполнению)

Когда вызван метод _start()_

BLOCKED (Заблокирован)

Когда обратился к ресурсу, монитор которого уже используется

WAITING (Ожидание)

Когда вызван метод _wait() или_ _join() или LockSupport.park()_

TIMED_WAITING (Ожидание с тайм-аутом)

Когда вызван метод _wait(millis)_ _или_ _join(millis) или_ _LockSupport._ _parkNanos(long nanos), LockSupport.parkUntil(long deadline)._

TERMINATED (Завершен)

Прерывание потока

Использование метода _interrupt_() устанавливает флаг прерывания потока, который должен обработаться пользователем внутри потока. Если метод был вызван, когда поток ждал (sleep, wait), то выбросится исключение InterruptedException.

  

Основные инструменты JavaUtilConcurrent

  
CountDownLatch — это синхронизатор из пакета _java.util.concurrent_, который позволяет одному или нескольким потокам ждать завершения набора операций, выполняемых в других потоках. Он использует счетчик, который отсчитывается до нуля; когда счетчик достигает нуля, ожидающие потоки пробуждаются и продолжают выполнение. Semaphore – управляет доступом к ресурсам с помощью счетчика разрешений.

·  Semaphore: Используется для ограничения доступа к ресурсу с возможностью контроля количества потоков, которые могут использовать ресурс одновременно.

·  CountDownLatch: Используется для координации потоков путем ожидания завершения набора операций или событий.

CyclicBarrier – позволяет группе потоков ждать друг друга и может использоваться повторно после того, как все потоки достигнут барьера.

Phaser – более гибкий синхронизатор, который можно использовать для координации фаз между потоками.

ReentrantLock – альтернатива synchronized, позволяющая управлять блокировкой напрямую посредством захвата, отпускания, проверки блокировки.

Потокобезопасные коллекции

Vector, Hashtable: Старые реализации потокобезопасных коллекций с синхронизацией на уровне методов.

ConcurrentHashMap, ConcurrentLinkedQueue, CopyOnWriteArrayList: Современные коллекции с улучшенной производительностью и потокобезопасностью.

Использование Collections.synchronizedList(), Collections.synchronizedMap():

Оборачивает неконкурентные коллекции для потокобезопасного доступа.

  

ThreadPool — это механизм управления группой потоков для выполнения параллельных задач. Повторно используются созданные потоки.

ExecutorService – интерфейс для работы с пулом потоков.

Executors – утилитный класс для создания различных типов пулов потоков

newFixedThreadPool(int nThreads) – фиксированное кол-во потоков

newCachedThreadPool() - если поток освободился, он будет повторно использован, если нет свободных потоков, создается новый. Если потоки остаются неиспользованными долгое время, они будут завершены.

newSingleThreadExecutor() – пул с одним потоком.

newScheduledThreadPool(int corePoolSize) – по расписанию

Управление и завершение:

shutdown(): Завершает прием новых задач и завершает работу пула после выполнения всех текущих задач.

shutdownNow(): Немедленно останавливает выполнение задач, пытается прервать работающие потоки и возвращает список невыполненных задач.

awaitTermination(): Ожидает завершения всех задач в пуле в течение указанного времени.  
  
  

ForkJoinPool

ForkJoinPool — это специализированный пул потоков в Java, предназначенный для эффективного выполнения задач, которые могут быть рекурсивно разделены на более мелкие подзадачи и затем объединены. Он был введен в Java 7 как часть пакета java.util.concurrent и реализует модель Fork/Join, которая оптимизирует использование многоядерных процессоров.

Основные концепции

Fork (разделение): Разделение сложной задачи на более мелкие подзадачи.

Join (объединение): Объединение результатов подзадач для получения окончательного результата.

Work-Stealing (кража работы): Механизм, при котором потоки, у которых нет работы, "крадут" задачи из очередей других потоков.

  

**Потокобезопасность**

**Потокобезопасность** (или **thread safety**) — это свойство программы или кода, которое гарантирует корректное и предсказуемое поведение при одновременном выполнении нескольких потоков.

Основные проблемы потокобезопасности:

Состояние гонки данных (Data Race):

Возникает, когда несколько потоков одновременно обращаются к одной переменной без надлежащей синхронизации, и хотя бы один из них выполняет запись.

Приводит к непредсказуемому поведению и ошибкам.

Взаимная блокировка (Deadlock):

Ситуация, когда потоки блокируют друг друга, ожидая ресурсов, удерживаемых другим потоком.

Результатом является зависание приложения.

Недостаточная видимость изменений (Visibility Issues):

Изменения, сделанные одним потоком, могут быть не видны другим из-за особенностей кэширования и оптимизаций процессора.

Разрывы атомарности (Atomicity Violations):

Операции, которые должны быть выполнены как единое целое, могут быть прерваны другим потоком, нарушая целостность данных.