Средства исследования и изменения структуры классов, методов, полей во время исполнения программы.

Использование рефлексии медленное (~10-100 раз) и небезопасное. 

**Runtime аннотации**
Runtime аннотации сохраняются в байт коде и с помощью рефлексии можно их прочитать.

### Почему рефлексия работает медленнее в Java

1. **Обход JVM-оптимизаций**  
    При обычных вызовах JVM заранее знает, какой метод вызывается → включает inlining, JIT-оптимизации.  
    При рефлексии метод неизвестен до runtime → inlining невозможен.
    
2. **Проверки безопасности**  
    Рефлексия всегда делает дополнительные проверки `AccessController`, прав доступа, модификаторов.
    
3. **Доступ к метаданным классов**  
    Рефлексия лезет в структуру Class/Method/Field → это операции с дополнительными объектами и lookup-ами.
    
4. **Вызов через посредников**  
    `method.invoke()` — это несколько уровней вызовов, упаковка/распаковка аргументов, переключение контекста.
    
5. **Boxing/unboxing + varargs**  
    Аргументы передаются как `Object[]`. Примитивы упаковываются, что дополняет накладные расходы.
    

### Итог

Рефлексия медленнее, потому что JVM не может оптимизировать такие вызовы и вынуждена выполнять больше проверок и вспомогательных операций, чем при обычном вызове метода.