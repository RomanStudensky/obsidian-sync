§### 1. Что такое `Stream` и зачем он появился?

`Stream` – это **ленивое** (элементы обрабатываются «по-требованию») представление последовательности данных, к которому можно применить декларативные операции – фильтрацию, отображение, агрегацию и т.п. API ввели в Java 8, чтобы:

- убрать «ручные» циклы и тем самым сделать код короче и понятнее;
    
- облегчить оптимизации (слияние нескольких проходов, «подглядывание» только к нужным элементам, автоматический параллелизм);
    
- перенести фокус с «как пройтись по данным» на «что с ними сделать». [docs.oracle.com](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html?utm_source=chatgpt.com)
    

**Потоковая конвейерная цепочка** состоит из двух видов операций

| Вид                                                         | Возвращает                 | Выполняется             | Назначение                                                                                                                                                               |
| ----------------------------------------------------------- | -------------------------- | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Промежуточная** (`filter`, `map`, `distinct`, `sorted` …) | новый `Stream`             | лениво                  | формирует конвейер, но сама ничего «не считает»                                                                                                                          |
| **Терминальная** (`forEach`, `collect`, `count`, `reduce…`) | значение / побочный эффект | _запускает_ всю цепочку | завершает конвейер; после неё поток использовать нельзя [docs.oracle.com](https://docs.oracle.com/javase/tutorial/collections/streams/index.html?utm_source=chatgpt.com) |
### 2. Можно ли из лямбды обращаться к внешней переменной?

Да, **если переменная окончательно (effectively) final** – то есть после первой инициализации её больше нигде не изменяют. Это то же самое правило, что и для локальных переменных, «захватываемых» внутренними/анонимными классами. Попытка присвоить новой значение вызовет ошибку компиляции. 

### 3. [[Stream & Parallel Stream]]

### 4. Разбор выражения

``` java 
Arrays.asList(1,2,3,4,5)
        .parallelStream()
        .map(i -> i * 2)
        .sum(); // <-- на Stream'е метода sum() нет!
```
- В таком виде код **не скомпилируется**: `map` даёт `Stream<Integer>`, у которого нет `sum()`.
    
- Правильный вариант:
``` java
Arrays.asList(1,2,3,4,5)
        .parallelStream()
        .mapToInt(i -> i * 2)   // IntStream
        .sum();                // вернёт 30    
```
- Что происходит:
    
1. **Spliterator** делит список на куски (например, по 2–3 элемента).
2. Для каждого куска в `ForkJoinPool.commonPool-worker-N` выполняется `mapToInt`.
3. Частичные суммы объединяются ассоциативной операцией `+` в дереве редукции; главный поток может участвовать, дожидаясь `join`.

### 5. Всегда ли полезно менять `stream()` на `parallelStream()?

Нет. Параллельный поток выгоден лишь когда:

- **Каждый элемент «тяжёлый»** (долгая CPU-работа или I/O);
- Источник хорошо дробится (без сильных зависимостей между элементами);
- Нет синхронизации/блокировок внутри операций;
- Экономия на многопоточности превышает накладные расходы на планирование задач и слияние результатов.

Проблемы, которые вы рискуете получить:

- **Снижение производительности** (мелкие операции, маленькие коллекции, Amdahl’s Law).
- **Потоки блокируются** на мониторах, I/O, `synchronized` секциях – `ForkJoinPool` не рассчитан на блокирующие задачи.
- **Голодание** других частей приложения, которые тоже используют `ForkJoinPool.commonPool`.
- **ConcurrentModification/side effects** – если операции пишут во внешние объекты или используют не-потокобезопасные коллекции.