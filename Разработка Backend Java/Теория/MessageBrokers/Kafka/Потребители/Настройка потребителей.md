
**fetch.min.bytes** – задает минимальный объем данных получаемых от брокера при извлечении записей – по умолчанию 1 байт. Если данных меньше, то брокер будет ждать пока не прилетят еще данные и отправит после.

**fetch.max.wait.ms –** задает время ожидания достаточного кол-ва данных для отправки потребителю. По умолчанию ждет 500мс (время долгое, приводит к дополнительной задержке).

**fetch.min.bytes –** задает максимальное количество байтов, которые Kafka будет возвращать каждый раз, когда потребитель опрашивает брокер. Если размер пакета больше, то он будет отправлен в любом случае.

**max.poll.records –** задает максимальное количество записей, которые возвращает один вызов функции _poll()._

**max.partition.fetch.bytes –** задает максимальное число байтов, возвращаемых сервером из расчета один раздел. При возврате методом _KafkaConsumer.poll()_ объекта ConsumerRecords объект записи будет занимать не более max.partition.fetch.bytes на каждый назначенный потребителю раздел.

**session.timeout.ms –** задает время, которое потребитель может считаться живым, до отправки контрольного сигнала.

**heartbeat.interval.ms –** задает частоту отправки контрольных сигналов координатору группы.

**max.poll.interval.ms –** задает продолжительность времени, в течение которого потребитель может обходиться без опроса, прежде чем будет признан мертвым.

**enable.auto.commit –** определят будет ли потребитель фиксировать смещение автоматически, по умолчанию _true_.  

**partition.assignment.strategy** – определяет какие разделы(партиции) к какому потребителю будут относиться. По дефолту _Range_

**Стратегии распределения:**

  

- **Диапазонная (Range)**. Каждому потребителю присваиваются последовательные подмножества разделов из топиков, на которые он подписан. Так что, если потребители C1 и C2 подписаны на топики T1 и T2, оба по три раздела, то потребителю C1 будут назначены разделы 0 и 1 из топиков T1 и T2, а C2 — раздел 2 из топиков T1 и T2. Поскольку в каждом из топиков нечетное число разделов, а их распределение по потребителям выполняется для каждого топика отдельно, у первого потребителя окажется больше разделов, чем у второго. Подобное происходит всегда, когда используется диапазонная стратегия распределения, а число потребителей не делится нацело на число разделов в каждом топике. 
- **Циклическая (RoundRobin)**. Все разделы от всех подписанных топиков распределяются по потребителям последовательно, один за другим. Если бы описанные ранее потребители C1 и C2 использовали циклическое распределение, C1 были бы назначены разделы 0 и 2 из топика T1 и раздел 1 из топика T2, а C2 — раздел 1 из топика T1 и разделы 0 и 2 из топика T2. Когда все потребители подписаны на одни и те же топики (очень распространенный сценарий), циклическое распределение дает одинаковое количество разделов у всех потребителей или в крайнем случае различие в один раздел. 
- **«Липкая» (Sticky)**. «Липкий» распределитель преследует две цели: первая состоит в том, чтобы получить максимально сбалансированное назначение, а вторая — в том, чтобы в случае перебалансировки оставить как можно больше назначений на месте, минимизируя накладные расходы, связанные с перемещением назначений разделов от одного потребителя к другому. В общем случае, когда все потребители подписаны на один и тот же топик, начальное назначение от «липкого» распределителя будет таким же сбалансированным, как и от циклического распределителя. Последующие назначения будут такими же сбалансированными, но уменьшат количество перемещений разделов. В случаях, когда потребители в одной группе подписаны на разные топики, распределение, достигнутое «липким» распределителем, будет более сбалансированным, чем у циклического распределителя. 
- **Совместная «липкая» (Cooperative Sticky)**. Эта стратегия назначения идентична стратегии назначения «липкого» распределителя, но поддерживает совместные перебалансировки, при которых потребители могут продолжать потреблять из разделов, которые не были переназначены. Подробнее о совместной перебалансировке читайте в подразделе «Группы потребителей и перебалансировка разделов» ранее в этой главе. Если вы переходите с версии старее 2.3, то для включения совместной стратегии «липкого» назначения вам необходимо будет следовать определенному пути обновления, поэтому обратите особое внимание на руководство по обновлению.

  

  

**client.id –** определяет идентификатор клиента, который применяется при журналировании и для показателей, а также при задании квот.

  

**client.rack –** определяет какой кластер выбрать для чтения. Можно описать свой класс, который будет делать выбор, исходя из описанной в нем логики.