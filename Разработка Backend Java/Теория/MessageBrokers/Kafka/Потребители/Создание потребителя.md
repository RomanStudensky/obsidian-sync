
 Создать экземпляра класса _KafkaConsumer_. Создать экземпляр класса _Properties_, содержащий свойства: _bootstrap.servers, key.deserializer_ и _value.deserializer_. Свойство _group.id_ не обязательно.

  
``` java

Properties props = new Properties();
props.put("bootstrap.servers", "broker1:9092,broker2:9092");
props.put("group.id", "CountryCounter");
props.put("key.deserializer", 
"org.apache.kafka.common.serialization.StringDeserializer");
props.put("value.deserializer", 
"org.apache.kafka.common.serialization.StringDeserializer");
KafkaConsumer<String, String> consumer = 
new KafkaConsumer<String, String>(props);
```

Цикл опроса. В самой основе API потребителей лежит простой цикл опроса сервера. Основной код потребителя выглядит следующим образом:

``` java

// определяет на какое время будет лочиться поток, пока ресурсы недоступны
Duration timeout = Duration.ofMillis(100);

while (true) {
	ConsumerRecords<String, String> records = consumer.poll(timeout);

	for (ConsumerRecord<String, String> record : records) { 
		System.out.printf("topic = %s, partition = %d, offset = %d, " +
		customer = %s, country = %s\n",
		record.topic(), record.partition(), record.offset(),
		record.key(), record.value());
		int updatedCount = 1;
		if (custCountryMap.countainsKey(record.value())) {
			updatedCount = custCountryMap.get(record.value()) + 1;
		}
		custCountryMap.put(record.value(), updatedCount)
		JSONObject json = new JSONObject(custCountryMap);
		System.out.println(json.toString());
	}
}
```

Железное правило: один потребитель на один поток.

Второй вариант - использовать аннотацию:

``` java

public class KafkaConfig {

    @Bean
    KafkaListenerContainerFactory
<ConcurrentMessageListenerContainer<Integer, String>>
                        kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<Integer, String> factory =
                                new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        factory.setConcurrency(3);
        factory.getContainerProperties().setPollTimeout(3000);
        return factory;
    }

    @Bean
    public ConsumerFactory<Integer, String> consumerFactory() {
        return new DefaultKafkaConsumerFactory<>(consumerConfigs());
    }

    @Bean
    public Map<String, Object> consumerConfigs() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        ...
        return props;
    }
}
```