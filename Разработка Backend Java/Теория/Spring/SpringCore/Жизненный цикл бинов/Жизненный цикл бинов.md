### 0 . Подготовка контейнера (до создания бинов)

|Шаг|Кто участвует|Для чего нужно|
|---|---|---|
|**Чтение конфигурации** (`@Configuration`, XML, `@ComponentScan`, AOT-hints)|`BeanDefinitionReader`, `ConfigurationClassParser`|Регистрируются `BeanDefinition`-ы.|
|**`BeanDefinitionRegistryPostProcessor`**|ваш код может программно добавлять/изменять `BeanDefinition` до того, как увидит их остальной контейнер [Home](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/BeanDefinitionRegistryPostProcessor.html?utm_source=chatgpt.com)||
|**`BeanFactoryPostProcessor`**|Дополнительная модификация метаданных (пример — `PropertySourcesPlaceholderConfigurer`). Выполняется уже после всех `BeanDefinitionRegistryPostProcessor`-ов, но **до** создания первого bean’а.||

> **Senior-note:** если вы добавляете бины динамически (например, для multi-tenant) — делайте это _только_ на этой фазе; иначе в AOT-режиме (native-image) они не попадут в хинты и приложение не поднимется. [Home](https://docs.spring.io/spring-framework/reference/core/aot.html?utm_source=chatgpt.com)

---

### 1 . Пред-инстанцирование

1. `InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation` - может вернуть _прокси_, полностью заменив оригинальный объект (пример — CGLIB-proxy для `@Transactional`).
2. Если прокси не возвращён — **конструктор / factory-method** создаёт экземпляр.

### 2 . Заполнение зависимостей

- `postProcessAfterInstantiation`
- `postProcessProperties` — точка, где работают `@Autowired`, `@Value`, `@Qualifier`.

### [[3 . Aware интерфейсы]]

Контейнер вызывает цепочку “Aware” сеттеров в строго фиксированном порядке — от `BeanNameAware` до `ApplicationContextAware` (11 позиций) [Home](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html).

> **Senior-note:** если вам нужна ранняя ссылка на контейнер (например, для «ручной» ленивой инициализации) — используйте `ObjectFactory<ApplicationContext>` вместо хранения контекста «как есть», чтобы не приковывать бины к полной инициализации.

### [[4 . BeanPostProcessor]]#postProcessBeforeInitialization

Часто здесь включаются infrastructure-BPP’ы (`CommonAnnotationBeanPostProcessor`, `ScheduledAnnotationBeanPostProcessor` и др.), которые ищут аннотации и готовят окружение. [Home](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html?utm_source=chatgpt.com)

### 5 . Инициализация самого бина

1. **`@PostConstruct`** / **`afterPropertiesSet`** (`InitializingBean`) / `init-method` — выполняются в lock’е контейнера — значит, тяжёлые операции (migrations, warm-up) здесь делать нельзя, иначе возникнет deadlock или увеличится время старта. [Home](https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html)
    
2. Если нужно «тяжёлое» прогревание — переносим его на:
    
    - `SmartInitializingSingleton#afterSingletonsInstantiated`
        
    - или слушаем `ContextRefreshedEvent` / `ApplicationReadyEvent`.
        

### 6 . `BeanPostProcessor#postProcessAfterInitialization`

Последний шанс обернуть объект в прокси (AOP, `@Async`, security-advices). После этого bean попадает в пул синглтонов и виден другим бинам.

### 7 . Поздние хуки приложения

|Механизм|Когда вызывается|Типовые use-case|
|---|---|---|
|`SmartInitializingSingleton`|Когда **все** singletons созданы|Кэширование, pre-warm pools|
|`ApplicationStartedEvent`|`SpringApplication.run()` → контекст готов, веб-порт ещё не слушает|Лёгкое логирование метрик запуска|
|`ApplicationReadyEvent`|Приложение приняло первый запрос|Тяжёлый прогрев, health-checks|

Spring Boot 3+ активно продвигает паттерн “инициализация через события”, потому что он более гибок и прозрачен для инструментов наблюдаемости [Medium](https://medium.com/%40ayoubseddiki132/deep-dive-into-spring-boot-3-bean-lifecycle-modern-approaches-and-best-practices-fcc46d7f87c2).

---

### 8 . Рабочая фаза и цикл жизни компонентов

- **`Lifecycle` / `SmartLifecycle`** — позволяют контейнеру управлять асинхронными службами (Kafka-listener, scheduler). `SmartLifecycle` имеет `phase` и `autoStartup=true`, что позволяет детально описать порядок старта/остановки.
    
- Для потокобезопасного старта используйте атомарные флаги (`running`), как рекомендует Boot-3 guide [Medium](https://medium.com/%40ayoubseddiki132/deep-dive-into-spring-boot-3-bean-lifecycle-modern-approaches-and-best-practices-fcc46d7f87c2).
    

---

### 9 . Завершение работы

Порядок обратный инициализации:

1. `DestructionAwareBeanPostProcessor#postProcessBeforeDestruction`
    
2. `@PreDestroy` / `DisposableBean#destroy` / `destroy-method`
    
3. Если бин реализует `Lifecycle` — сначала вызывается `stop()` (с тайм-аутом в `SmartLifecycle`) [Home](https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html).
    

> **Senior-note:**
> 
> - В Boot 3+ есть «graceful shutdown» хук сервера; используйте `ContextClosedEvent` для асинхронного завершения активных операций, особенно в reactive-стеке. [Medium](https://medium.com/%40ayoubseddiki132/deep-dive-into-spring-boot-3-bean-lifecycle-modern-approaches-and-best-practices-fcc46d7f87c2)
>     
> - **Prototype**-scoped бины контейнер не уничтожает — ответственность на вызывающей стороне.
>     

---

## Распространённые ошибки, на которые смотрят на собеседованиях

|Ошибка|Как избежать|
|---|---|
|**Логика в конструкторе** (зависимости ещё не внедрены)|Перенесите в `@PostConstruct` или событие.|
|**Тяжёлая работа в `@PostConstruct`** → долгий старт, deadlock|Перенести на `ApplicationReadyEvent` или `SmartInitializingSingleton`.|
|**Хрупкая зависимость от порядка старта**|Используйте `@DependsOn` или `SmartLifecycle#phase`, а не магический `@Order`.|
|**Неразрываемые циклические зависимости**|Внедряйте через конструктор + `@Lazy` или `ObjectProvider`, либо рефакторите архитектуру.|
|**Память не освобождается** (listener не отписан)|Подпишитесь на `ContextClosedEvent` и снимайте все ресурсы.|
|**Скрытые прокси** мешают AOT / Native|Минимизируйте runtime-прокси; проверяйте `--verbose` отчёт AOT-компилятора.|

---

## Чек-лист Senior-разработчика

1. **Понимаю полный порядок вызовов** (Aware → BPP → @PostConstruct → SmartInitializingSingleton …) и могу объяснить, почему так. [Home](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html)[Home](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html?utm_source=chatgpt.com)
    
2. **Умею пользоваться extension-точками** (`BeanDefinitionRegistryPostProcessor`, `ImportBeanDefinitionRegistrar`, собственные BPP) для динамических сценариев. [Home](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/BeanDefinitionRegistryPostProcessor.html?utm_source=chatgpt.com)
    
3. **Использую событийную модель Boot 3** (`Application*Event`, `Context*Event`) для ясного и управляемого старта/остановки приложения. [Medium](https://medium.com/%40ayoubseddiki132/deep-dive-into-spring-boot-3-bean-lifecycle-modern-approaches-and-best-practices-fcc46d7f87c2)
    
4. **Знаю ограничения AOT/Native** и где нужно регистрировать бины или рефлексию. [Home](https://docs.spring.io/spring-framework/reference/core/aot.html?utm_source=chatgpt.com)
    
5. **Могу профилировать старт (Micrometer `ApplicationStartup`)** и объяснить, как сократить «горячие» пути.
    

Освоив эти пункты, вы не просто «знаете, когда вызывается @PostConstruct», а осознанно управляете жизненным циклом приложения, что и ожидается от Senior.
