### Пост-процессоры в Spring: «где» и «зачем»

| Категория                                 | Когда вызывается                                                      | Что можно делать                                                     | Типичные примеры                                                                                       |
| ----------------------------------------- | --------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| **`BeanDefinitionRegistryPostProcessor`** | _Сразу после_ чтения конфигурации, **до** создания **первого** bean’а | Регистрировать/удалять/изменять `BeanDefinition`                     | `ConfigurationClassPostProcessor` (сканирует `@Configuration`), MyBatis `MapperScanner`                |
| **`BeanFactoryPostProcessor`**            | После BDR-PP, но всё ещё **до** инстанцирования                       | Менять свойства/скоупы, добавлять `init-method`, чтение внешних YAML | `PropertySourcesPlaceholderConfigurer`, `SpringDoc` OpenAPI customizer                                 |
| **`BeanPostProcessor`**                   | Для **каждого** экземпляра: **до** и **после** инициализации          | Обернуть proxy, внедрить зависимости вручную, валидировать состояния | `AutowiredAnnotationBeanPostProcessor`, `AnnotationAwareAspectJAutoProxyCreator`, Hibernate `JpaProxy` |
| `InstantiationAwareBeanPostProcessor`     | ещё **до** конструктора                                               | Подменить bean (lazy-proxy), изменить поля до `@Autowired`           | `ScopedProxyCreator`, `Spring Security` advisors                                                       |
| `DestructionAwareBeanPostProcessor`       | перед уничтожением                                                    | Почистить ресурсы, снять listener’ы                                  | `DisposableBeanAdapter`                                                                                |
| `MergedBeanDefinitionPostProcessor`       | один раз на класс                                                     | Кешировать аннотации для AOT                                         | `ConfigurableApplicationContextAwareProcessor`                                                         |

---

#### 1. Динамическая регистрация бинов (BDR-PP)

``` java
@Bean
static BeanDefinitionRegistryPostProcessor addRepo() {
  return (registry) -> {
      GenericBeanDefinition bd = new GenericBeanDefinition();
      bd.setBeanClass(GitRepository.class);
      registry.registerBeanDefinition("gitRepo", bd);
  };
}
```

_Где полезно:_ multi-tenant → создаём `DataSource` на лету, и он **попадает** в AOT.

---

#### 2. Глобальное изменение метаданных (BF-PP)

``` java
@Bean
static BeanFactoryPostProcessor readYaml() {
  return (bf) -> {
     YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean();
     yaml.setResources(new ClassPathResource("extra.yml"));
     bf.addPropertySource(new PropertiesPropertySource("extra", yaml.getObject()));
  };
}

```
_Заменяет устаревший `@PropertySource`, работает до старта._

---

#### 3. Авто-прокси и custom-инъекция (BPP)

``` java
@Component
class LoggerInjector implements BeanPostProcessor {
  @Override
  public Object postProcessBeforeInitialization(Object bean, String name) {
      Arrays.stream(bean.getClass().getDeclaredFields())
            .filter(f -> f.getType() == Logger.class)
            .forEach(f -> {
               ReflectionUtils.makeAccessible(f);
               f.set(bean, LoggerFactory.getLogger(bean.getClass()));
            });
      return bean;
  }
}
```

_Инъектируем `Logger` без Lombok._

---

#### 4. Подмена singleton до конструктора (IABPP)

``` java
@Component
class LazyProxyCreator implements InstantiationAwareBeanPostProcessor {
  public Object postProcessBeforeInstantiation(Class<?> beanClass, String name) {
     if(beanClass.isAnnotationPresent(LazyProxy.class)) {
        return Proxy.newProxyInstance(beanClass.getClassLoader(),
                beanClass.getInterfaces(),
                (p,m,a) -> { /* ленивое создание */ });
     }
     return null; // вернём null → Spring вызовет конструктор
  }
}
```

_Используется в `@Transactional` и `@Async`._

---

### Порядок вызова (singleton)

1. **BDR-PP** (`PriorityOrdered` → `Ordered` → остальные)
2. **BF-PP** (тот же порядок)
3. Регистрация **BPP** (тоже `PriorityOrdered` → …)
4. Для каждого bean’а
    1. `InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation`
    2. **конструктор**
    3. инъекция `@Autowired`
    4. цепочка `BeanPostProcessor#postProcessBeforeInitialization`
    5. `@PostConstruct` / `afterPropertiesSet`
    6. цепочка `postProcessAfterInitialization`
5. При `context.close()` → `DestructionAwareBeanPostProcessor` → `@PreDestroy`

---

### Практические рекомендации

- **Статические `@Bean`-фабрики** для BF/BDR-PP ― иначе они сами станут «ранними» бинами.
- **Не делайте тяжёлый I/O** в BPP: всё ещё держится global-lock контейнера.
- Хотите гарантированный порядок? Реализуйте `PriorityOrdered` или добавьте `@Order`.
- В native-image избегайте «runtime-proxy» в BPP ― регистрируйте типы в hints.
- Тесты: подключайте pp через `@TestConfiguration` → меньше зависимостей.

---

**TL;DR** Пост-процессоры — это расширяемые хуки Spring, позволяющие:

- на уровне **метаданных** — добавлять/менять `BeanDefinition` до старта;
- на уровне **экземпляров** — внедрять логеры, проксировать AOP, валидировать, чистить.  
    Senior-разработчик точно знает, **в какой фазе** внести изменение, чтобы оно не «вылезло» в AOT и не сломало порядок инициализации.