Индексы, которые создаются, не прерывая *DML* операции.
Такое преимущеcтво достигается за счет повторного чтения.

# Команды (PostgreSQL)

- Создание:  
    `CREATE INDEX CONCURRENTLY idx ON tab(col);`
- Уникальный:  
    `CREATE UNIQUE INDEX CONCURRENTLY uidx ON tab(col);`
- Перестройка:  
    `REINDEX INDEX CONCURRENTLY idx;` или `REINDEX TABLE CONCURRENTLY tab;`
- Удаление:  
    `DROP INDEX CONCURRENTLY idx;`


# Плюсы

- Практически не стопорит прод: DML продолжаются.
- Подходит для больших таблиц и 24/7 систем.

# Минусы и нюансы

- **Дольше** и **тяжелее** по I/O (в 2-3 раза): делается несколько проходов + валидация.
- Нельзя внутри `BEGIN; … COMMIT;` — «вне транзакционного блока».
- Берутся «мягкие» *DDL*-локи (конфликтуют с `VACUUM FULL/CLUSTER/EXCLUSIVE DDL`), но **не** блокируют обычные запросы.
- Если создаёте ***UNIQUE***, а в момент валидации найдены дубликаты — операция упадёт.
- При ошибке может остаться `INVALID` индекс; повторите `DROP INDEX CONCURRENTLY`/пересоздайте.

# Практика

- Перед уникальным индексом часто чистят дубликаты:    
    `-- найти дубликаты SELECT col, COUNT(*) FROM tab GROUP BY col HAVING COUNT(*)>1;`

- Для больших таблиц добавление ограничения через индекс:
    `CREATE UNIQUE INDEX CONCURRENTLY uidx_tab_col ON tab(col); ALTER TABLE tab ADD CONSTRAINT tab_col_uk UNIQUE USING INDEX uidx_tab_col;`

- Перестройка «на лету», если индекс раздулся/повреждён:
    `REINDEX INDEX CONCURRENTLY idx_tab_col;`

# Когда использовать

- Прод с высокой нагрузкой, где недопустим простой на время DDL.
- Ночные окна маленькие или отсутствуют.
- Большие GIN/B-Tree индексы, где обычный `CREATE INDEX` дал бы долгий блокирующий эксклюзив-лок.

Если у вас не PostgreSQL: аналог — **MySQL/InnoDB ONLINE DDL**, **SQL Server `WITH (ONLINE = ON)`**, **Oracle ONLINE INDEX** — смысл тот же: онлайн-строительство/валидирование с минимальными блокировками.