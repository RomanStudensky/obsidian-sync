
**Преимущества:**

- Ускорение запросов _SELECT_ по определенным значениям столбцов.
- Ускоряют объединение таблиц (_JOIN_) по индексированным столбцам.

**Недостатки:**

- Индексы занимают дополнительное место на диске
- При изменении данных индексы обновляются, что замедляет операции: _INSERT, UPDATE, DELETE_. Замедление пропорционально количеству записей в таблице.

**Нюансы использования индексов:**

- Несколько (**перекрывающих**) индексов с одинаковыми или похожими столбцами - может быть избыточно и не приносить пользы

- Индексы на столбцах с низкой уникальностью значений - бесполезны, т.к. оптимизатор может не использовать их

- Если запрос включает только часть полей индекса? 
	Например, поля со значениями *a(1), b(2), c(3)*. 
	Сортировка происходит от *a* до *c*. Соответственно, если искать поля не в порядке индекса, то это будет дольше. Например, если искать только по *b*, сначала произойдет перебор по всем *a*, а после по *b*. Такой вариант будет дольше


**Высокая частота обновления данных таблицы**
	При высокой частоте обновления таблицы часто меняется содержимое таблицы. При этом операции _VACUUM_ и _ANALYZE,_ обновляющие статистику таблицы, выполняются автоматически в определенное системой время. Запрос может случиться, когда таблица и индекс имеют неактуальную статистику. В таком случае план запроса будет построен не оптимально.  
	**Решение**: ==вызывать _ANALYZE_ вручную или по расписанию==; настроить параметры _autovacuum_analyze_threshold_ и _autovacuum___analyze___scale___factor_ (уменьшение приводит к учащению обновления).

**Разделы темы:**
[[Кластерные индексы]]
[[Конкурентные индексы]]
[[Типы индексов]]
[[PostgreSQL схемы, индексы, чтение EXPLAIN]]
[[GIST GIN]]