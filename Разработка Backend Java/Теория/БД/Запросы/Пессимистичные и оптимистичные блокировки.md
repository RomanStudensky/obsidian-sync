
**Оптимистическая блокировка** сущности в таблице БД в конкурентной обработке достигается применением поля версии. Перед изменением данных нужной сущности или совершении действий, зависящих от значений полей этой строки необходимо сравнить её версию с актуальным значением версии из БД. Если версии не совпадаю, можно выкинуть исключение или обработать любым другим способом.

При использовании Hibernate достаточно поставить аннотацию `@Version`
Если версии не совпадут, будет выброшено исключение `OptimisticLockException`
```java
@Entity
public class Account {
    @Id
    private Long id;
    private BigDecimal balance;
    @Version               // Hibernate сам добавит проверку version
    private int version;
}
```


Для использования **пессимистической блокировки** достаточно использовать оператор `FOR UPDATE`, чтобы заблокировать сущность для чтения и изменения.
```sql
BEGIN;
-- ставим блокировку на строку (только один может изменить)
SELECT * FROM account WHERE id = 1 FOR UPDATE;
-- делаем изменения
UPDATE account SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

Так же есть градации блокировок. Примеры для PostgreSQL
**Варианты:**
- `FOR UPDATE` — самая жёсткая, блокирует изменения строки.
- `FOR NO KEY UPDATE` — блокирует UPDATE/DELETE, но «мягче» (не конфликтует с `FOR SHARE/KEY SHARE`). Полезно, когда нельзя менять ключи.
- `FOR SHARE` — «чтение с разделяемой блокировкой». Конфликтует с изменениями.
- `FOR KEY SHARE` — ещё мягче: защищает только «ключевые» поля (уникальные/PK), позволяет неблокирующие чтения.

**Модификаторы:**
- `NOWAIT` — не ждать, сразу ошибка при конфликте.
- `SKIP LOCKED` — пропускать уже заблокированные строки (идеально для очередей/воркеров).
- `OF table_alias` — ограничить блокировку конкретной таблицей в JOIN.